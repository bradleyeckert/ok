# SPI Flash

The firmware functions that access SPI Flash are:
```C
int NVMbeginRead (uint32_t faddr);
int NVMbeginWrite (uint32_t faddr);
uint32_t NVMread (int bytes);
void NVMwrite (uint32_t n, int bytes);
void NVMendRW (void);
```
These are included in the VM as `NVM@[`, `NVM![`, `NVM@`, `NVM!`, and `NVM`.

NVM (non-volatile memory)
is implemented using a 32Mb (4 MB) SPI Flash such as
Winbond W25Q32JVSSIQ connected to the MCU's SPI.
Future SPI Flash parts may bigger.
For example, the Winbond W25Q256JVEIQ (512 64KB sectors) is under $2.
The Winbond W25Q01JVZEIQ (2048 64KB sectors) is under $10.

The first 4KB sector of SPI Flash contains a list of blobs.
Each 2-byte table entry consists of:

- 2-byte first 64KB sector
- 2-byte last 64KB sector
- 16-byte HMAC

The table is a simple linear list.
A "first sector" value of FFFFh terminates the list.
Sector 0 address range is 00001000h to 0000FFFFh. Otherwise,
sector N address range is NNNN0000h to NNNNFFFFh.

The HMAC is a digital signature generated by the MCU.
The private key for the HMAC is in the MCU, preferably a random number
generated by the MCU before programming the SPI Flash.
The HMAC is used to prevent application launch if any blob is bad.

## Programming

No write protection, either hard or soft, is used in this application.
The root-of-trust is internal MCU firmware.
The MCU allows for encrypted SPI Flash Programming.
The MCU uses a self-generated permanent private key for
encrypting and decrypting SPI Flash.
There are two ways to get plaintext data into the MCU for programming:

- An update file on the Micro-SD card.
- An encrypted debug UART.

The update file uses the mole protocol, which uses pre-arranged unique private keys.
The update file only works for one particular device or manufacturing lot.

The UART uses the mole protocol, which uses pre-arranged unique private keys.
The host PC would be controlled by the manufacturer to get the keys for
that particular device. Plaintext stays within the host PC.

## The blobs

The system has several blobs in the NVM:

| idx | blob usage |
|-----|------------|
| 0 | Fonts for the LCD - multi-lingual messages and glyph bitmaps |
| 1 | Primary application image - VM bytecode                      |
| 2 | Secondary application image - VM bytecode                    |
| 3 | Primary system boot image - binary executable                |
| 4 | Secondary system boot image - binary executable              |
| 5 | Staging area for firmware update                             |

For testing in the host VM, a `spiflash.bin` file is loaded by `ok`.
A `blobcmp` utility creates `spiflash.bin` from binary blob files.
It does not generate a HMAC since it only used for development.

Each blob starts with a version number. At boot time, the MCU will check
the version number against the version number of the update image file if it exists.
Rollbacks are prevented by having version numbers covered by blob HMACs so they
cannot be tampered with. The blob's preamble is:

- 4-byte version in ASCII format
- 4-byte blob size in bytes

The `spiflash.bin` image can be used as the source for update files.
A utility would convert each blob to mole format.

# 0. Messages and fonts

The messages and fonts are compiled by the `fontgen` utility.
See `make.f` in the `utilities/fontgen` folder.
Links within the font are generally 24-bit. 
This blob of data consists of:

- 4-byte version
- 4-byte blob size in bytes
- 4-byte address of messages table
- 4-byte size of messages table
- 4-byte address of font structure
- Messages table, 3-byte address for each entry
- Fonts structure

# 1, 2. Bytecode application images

The application image is loaded into MCU RAM at boot time.
See `make.f` in the `utilities/fontgen` folder.
Links within the font are generally 24-bit. 
This blob of data consists of:

- 4-byte version
- 4-byte blob size in bytes
- 4-byte size of code blob in bytes
- 4-byte size of text blob in bytes
- Little-endian data (code, text)
