/*
 * okuart.c
 *
 *  Created on: May 14, 2025
 *      Author: Bradley Eckert
 *
 * Interrupt-driven UART buffering and I/O
 * UARTs are initialized by startup code generated by MX.
 * See okuart.h for part-specific dependencies.
 */

#include <string.h>
#include <stdint.h>
#include "okuart.h"

void UARTx_init (UART_t *handle, USART_TypeDef *device) {
	memset(handle, 0, sizeof(UART_t));
	handle->dev = device;
	device->CR1 |= USART_CR1_RXNEIE;
	device->CR1 |= USART_CR1_UE;
}

void UARTx_IRQHandler(UART_t *uart) {
	if (uart->dev->ISR & USART_ISR_RXNE_RXFNE) {
    	uart->r_buffer[uart->r_head++] = uart->dev->RDR;
    	if (uart->r_head == uart->r_tail)		// overflow detected
    		uart->r_overflow = 1;
#ifndef READING_RDR_CLEARS_RXNE
		uart->dev->ISR &= ~USART_ISR_RXNE_RXFNE;
#endif
    }
    if (uart->dev->ISR & USART_ISR_TXE_TXFNF) {
    	if (uart->t_head == uart->t_tail) {		// disable TX interrupt if done
    		uart->dev->CR1 &= ~USART_CR1_TXEIE;
    	} else {
    		uart->dev->TDR = uart->t_buffer[uart->t_tail++];
#ifndef WRITING_TDR_CLEARS_TXFNF
    		uart->dev->ISR &= ~USART_ISR_TXE_TXFNF;
#endif
    	}
    }
}

int UARTx_headroom(UART_t *uart) {
	return uart->t_tail - uart->t_head;
}

/* Add c to a soft FIFO and rely on the ISR to send it from the FIFO.
 * The TXEIE flag indicates whether the FIFO is in play.
 */
void UARTx_putc(UART_t *uart, uint8_t c) {
 	while (UARTx_headroom(uart) == 1) {} 		// buffer is full
	uart->t_buffer[uart->t_head++] = c;
	if ((uart->dev->CR1 & USART_CR1_TXEIE) == 0) {
		uart->dev->ISR |= USART_ISR_TXE_TXFNF;
	 	uart->dev->CR1 |= USART_CR1_TXEIE;
	}
}

void UARTx_puts(UART_t *uart, const uint8_t *src, int length) {
	while (length--) UARTx_putc(uart, *src++);
}

int UARTx_received(UART_t *uart) {
	return uart->r_head - uart->r_tail;
}

int UARTx_getc(UART_t *uart) {
	if (UARTx_received(uart) == 0) return -1;
	return uart->r_buffer[uart->r_tail++];
}

int UARTx_peek(UART_t *uart) {
	if (UARTx_received(uart) == 0) return -1;
	return uart->r_buffer[(uart->r_head - 1) & 0xFF];
}
